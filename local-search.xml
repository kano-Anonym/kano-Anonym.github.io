<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>我的C/C++面试</title>
    <link href="/2023/12/12/C++%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <url>/2023/12/12/C++%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>一定提前准备好个人介绍!<br>一定提前准备好个人介绍!<br>一定提前准备好个人介绍!</p>          </div><div class="note note-primary">            <p>一定不紧张!一定不着急!<br>慢慢思考面试官提出的问题,理一理再作答!</p>          </div><h1 id="一-第一次面试的面试题"><a href="#一-第一次面试的面试题" class="headerlink" title="一. 第一次面试的面试题"></a>一. 第一次面试的面试题</h1><div class="note note-info">            <p>非常大打击,太紧张了,面试官问题刚出来都没思考就直接做答,前言不搭后语,根本不知道在说什么,很多了解过的问题居然没有想出来!!!</p>          </div><p>不做具体的描述,只写一些怎么回答</p><h2 id="1-对数据结构和算法有什么了解"><a href="#1-对数据结构和算法有什么了解" class="headerlink" title="1. 对数据结构和算法有什么了解"></a>1. 对数据结构和算法有什么了解</h2><h4 id="a-强调基础知识"><a href="#a-强调基础知识" class="headerlink" title="a. 强调基础知识"></a>a. 强调基础知识</h4><pre><code class="hljs">  a. 指出对常见数据结构(数组,链表,栈,队列,树,图等)和算法(排序,查找,递归,动态规划等)有扎实的理解;  b. 提到对这些数据结构和算法的特性,优势和劣势的理解;  c. 对于C++,可以补充对于C++的STL中各种容器的底层比较了解并且能够模拟实现出vector,list等.</code></pre><h4 id="b-项目经验"><a href="#b-项目经验" class="headerlink" title="b. 项目经验"></a>b. 项目经验</h4><pre><code class="hljs">  强调在实际项目中如何应用数据结构和算法来解决问题,说明在解决某个特定问题时选择了什么样的数据结构  和算法,并研究其性能和效率;</code></pre><h4 id="c-学习和实践"><a href="#c-学习和实践" class="headerlink" title="c. 学习和实践"></a>c. 学习和实践</h4><pre><code class="hljs">  a. 说明自己是否参与过在线课程,刷过算法题,参加过编程竞赛或者某些开源项目;  b. 展示自己对该领域的兴趣和投入</code></pre><h4 id="d-解决问题的思考方式"><a href="#d-解决问题的思考方式" class="headerlink" title="d. 解决问题的思考方式"></a>d. 解决问题的思考方式</h4><pre><code class="hljs">  a. 说明自己在面对复杂问题时如何分析,拆解和设计解决方案的  b. 举例说明自己的思考过程</code></pre><h4 id="e-例子"><a href="#e-例子" class="headerlink" title="e. 例子:"></a>e. 例子:</h4><pre><code class="hljs">  &quot;我在大学学习期间，通过课程和自学建立了坚实的数据结构和算法基础。我熟悉常见的数据结构，如数组、链表、  栈和队列，并了解它们的应用场景和性能特点。在算法方面，我有经验处理排序、查找、递归和动态规划等问题。  在实际项目中，我曾使用过数据结构和算法来解决性能瓶颈和优化代码。我也积极参与在线学习，刷题，以不断提升  自己。我相信我的数据结构和算法知识可以帮助我更好地解决工程中的复杂问题。&quot;</code></pre><h2 id="2-编程场景问题的解决"><a href="#2-编程场景问题的解决" class="headerlink" title="2. 编程场景问题的解决"></a>2. 编程场景问题的解决</h2><div class="note note-primary">            <p>真的是之前从没有接触过这方面的问题!!!</p>          </div><h3 id="常见的编程场景问题"><a href="#常见的编程场景问题" class="headerlink" title="常见的编程场景问题"></a>常见的编程场景问题</h3><ol><li>查找问题   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">问题： 在一个有序数组中查找特定元素。<br>算法： 二分查找。<br>示例： 在有序数组 [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>] 中查找元素 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure></li><li>排序问题   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">问题： 对一个数组进行排序。<br>算法： 快速排序、归并排序、冒泡排序等。<br>示例： 使用快速排序对数组 [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>] 进行<br><br>问题： 一亿个数里面找最小的一百个数。<br>算法： 大堆排序<br>示例： 在这个场景中，可以考虑使用最小堆（Min Heap）来解决问题。最小堆是一种数据结构，<br>其中每个节点的值都小于或等于其子节点的值。通过维护一个最小堆，我们可以有效地找到最小的 k 个元素。<br>建立一个大小为k的最小堆,用于存储当前找到的最小的k个数.遍历一亿个数,将每个数与堆顶元素进行比较:<br><span class="hljs-keyword">if</span>(num[i] &gt; _top_max) &#123;<span class="hljs-comment">//当前数大于大堆堆顶元素,则跳过</span><br>   <span class="hljs-keyword">continue</span>;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-built_in">DownHeap</span>(num[i]);<span class="hljs-comment">//当前数小于大堆堆顶元素,与其比较,向下调整</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>链表问题   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">问题： 反转一个链表。<br>算法： 迭代法、递归法。<br>示例： 将链表 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span> 反转成 <span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure></li><li>树的遍历问题   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">问题： 实现二叉树的前序、中序或后序遍历。<br>算法： 深度优先搜索（DFS）。<br>示例： 对二叉树进行中序遍历。<br></code></pre></td></tr></table></figure></li><li>动态规划问题   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">问题： 爬楼梯问题。<br>算法： 动态规划。<br>示例： 有 n 级楼梯，每次可以爬 <span class="hljs-number">1</span> 或 <span class="hljs-number">2</span> 级，有多少种不同的方法可以爬到楼顶<br></code></pre></td></tr></table></figure></li><li>哈希表问题   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">问题： 两数之和。<br>算法： 哈希表。<br>示例： 在数组 [<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>] 中找到两个数的和等于目标数 <span class="hljs-number">9</span>。<br></code></pre></td></tr></table></figure></li><li>栈和队列问题   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">问题： 有效的括号。<br>算法： 栈。<br>示例： 判断一个字符串中的括号是否匹配。<br></code></pre></td></tr></table></figure></li><li>图问题   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">问题： 课程表（检测有向图中是否有环）。<br>算法： 拓扑排序。<br>示例： 判断是否可以完成一系列课程的学习。<br></code></pre></td></tr></table></figure></li><li>贪心算法问题   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">题： 分发饼干。<br>算法： 贪心算法。<br>示例： 给定孩子的满足度和饼干的大小，最多能满足多少孩子。<br></code></pre></td></tr></table></figure></li><li>并查集问题   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">问题： 冗余连接（查找图中的环）。<br>算法： 并查集。<br>示例： 从一系列边中找到导致图中环的最后一条边。<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-红黑树"><a href="#3-红黑树" class="headerlink" title="3. 红黑树"></a>3. 红黑树</h2><p>我就面试个实习岗,好久没看过了居然还把这个给拉出来了</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>   红黑树（Red-Black Tree）是一种自平衡的二叉搜索树，它在插入和删除节点时通过一系列的旋转和着色操作来保持树的平衡，以确保其高度始终保持在对数级别。红黑树在算法和数据结构中被广泛应用，例如在关联容器的实现（如C++中的std::map和std::set）以及文件系统的某些实现中。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><h4 id="1-自平衡性"><a href="#1-自平衡性" class="headerlink" title="(1)自平衡性"></a>(1)自平衡性</h4><pre><code class="hljs">  红黑树是一种自平衡的二叉搜索树，通过在插入和删除节点时进行旋转和重新着色等操作，保持了树的平衡。  这确保了树的高度保持在对数级别，使得在查找、插入和删除等操作的时间复杂度保持在O(log n)级别。</code></pre><h4 id="2-节点颜色"><a href="#2-节点颜色" class="headerlink" title="(2)节点颜色"></a>(2)节点颜色</h4><pre><code class="hljs">  每个节点要么是红色，要么是黑色。这种着色规则有助于满足红黑树的平衡性质。</code></pre><h4 id="3-根节点特性"><a href="#3-根节点特性" class="headerlink" title="(3)根节点特性"></a>(3)根节点特性</h4><pre><code class="hljs">  树的根节点是黑色的。这是为了确保路径规则成立，从而保证树的整体平衡性。</code></pre><h4 id="4-红色节点特性"><a href="#4-红色节点特性" class="headerlink" title="(4)红色节点特性"></a>(4)红色节点特性</h4><pre><code class="hljs">  如果一个节点是红色的，则它的子节点必须是黑色的。这个规则保证了没有两个相邻的红色节点，从而避免了潜在的  不平衡情况。</code></pre><h4 id="5-叶子节点特性"><a href="#5-叶子节点特性" class="headerlink" title="(5)叶子节点特性"></a>(5)叶子节点特性</h4><pre><code class="hljs">  每个叶子节点（通常是NULL或NIL节点）是黑色的。这使得在计算路径上的黑色节点数量时，将叶子节点也考虑在内。</code></pre><h4 id="6-路径规则"><a href="#6-路径规则" class="headerlink" title="(6)路径规则"></a>(6)路径规则</h4><pre><code class="hljs">  从任意节点到其每个叶子节点的路径上包含相同数量的黑色节点。这个规则确保了树的整体平衡性，因为在最坏情况  下，任何路径的长度最多是其它路径长度的两倍。</code></pre><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="1-自平衡性-1"><a href="#1-自平衡性-1" class="headerlink" title="(1)自平衡性"></a>(1)自平衡性</h4><pre><code class="hljs">  红黑树通过自动的旋转和着色操作保持平衡，确保了树的高度保持在对数级别。这使得在查找、插入和删除等操作的  时间复杂度能够保持在O(log n)级别。</code></pre><h4 id="2-高效的插入和删除操作"><a href="#2-高效的插入和删除操作" class="headerlink" title="(2)高效的插入和删除操作"></a>(2)高效的插入和删除操作</h4><pre><code class="hljs">  由于红黑树的自平衡性，插入和删除节点时的性能表现相对较好。这使得红黑树在需要频繁插入和删除操作的场景  中具有优势。</code></pre><h4 id="3-有序性"><a href="#3-有序性" class="headerlink" title="(3)有序性"></a>(3)有序性</h4><pre><code class="hljs">  红黑树是一种二叉搜索树，保持了节点的有序性。这使得在红黑树上进行范围查询等操作非常高效。</code></pre><h4 id="4-广泛应用"><a href="#4-广泛应用" class="headerlink" title="(4)广泛应用"></a>(4)广泛应用</h4><pre><code class="hljs">  红黑树的自平衡性使得它在各种领域得到广泛应用，包括实现关联容器（例如C++中的std::map和std::set）和  文件系统等。</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="1-相对复杂"><a href="#1-相对复杂" class="headerlink" title="(1)相对复杂"></a>(1)相对复杂</h4><pre><code class="hljs">  红黑树的实现相对复杂，因为需要处理旋转和着色等复杂的操作。相比于其他平衡二叉树，例如AVL树，红黑树的  实现可能更难理解和调试。</code></pre><h4 id="2-非常数因子"><a href="#2-非常数因子" class="headerlink" title="(2)非常数因子"></a>(2)非常数因子</h4><pre><code class="hljs">  尽管红黑树在平均情况下具有对数级别的性能，但在最坏情况下，仍然不是常数因子。有些操作可能涉及到多次旋  转，导致性能略有下降。</code></pre><h4 id="3-内存占用"><a href="#3-内存占用" class="headerlink" title="(3)内存占用"></a>(3)内存占用</h4><pre><code class="hljs">  由于每个节点需要存储颜色信息，相对于普通的二叉搜索树，红黑树在内存占用上会有一些额外开销。</code></pre><h2 id="4-进程-线程与协程"><a href="#4-进程-线程与协程" class="headerlink" title="4. 进程, 线程与协程"></a>4. 进程, 线程与协程</h2><p>本来已经准备过的,但是问题一提出来我张口就说,很乱,说完几句脑子瞬间就是一片空白…</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><pre><code class="hljs">  进程是计算机中运行中的程序的实例,是操作系统中一个独立的程序执行单元，它包括程序、数据和进程控制块  等资源。一个进程可以拥有多个线程，共享相同的资源。</code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre><code class="hljs">  独立性：进程是独立的执行单元，各个进程之间相互独立，彼此不受影响。  资源分配：进程有自己的地址空间和系统资源，彼此之间不能直接访问。有独立的内存空间、文件描述符等系统资源。  隔离性：进程之间的隔离性使得一个进程的崩溃不会影响其他进程的稳定性。  并发性：多个进程可以同时运行，彼此之间不受影响。  系统开销：创建和维护进程需要占用系统资源。</code></pre><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><pre><code class="hljs">  强隔离性：进程之间互相独立，一个进程的崩溃不会影响其他进程。  稳定性：一个进程的错误通常不会对其他进程产生负面影响。</code></pre><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><pre><code class="hljs">  线程是进程中的一个执行单元，多个线程可以在同一个进程中并发执行，共享相同的内存空间和数据。是程序执行的  最小单位，由线程控制块、寄存器集合和栈组成。同一进程中的多个线程共享相同的进程资源。</code></pre><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><pre><code class="hljs">  共享资源：线程属于同一进程，共享进程的地址空间和系统资源。  轻量级：相比于进程，线程更轻量，创建和销毁以及切换线程的开销较小。  独立性：线程有自己的栈，寄存器集合，但共享进程的其他资源。  并发性：线程可以实现并发执行，提高程序的响应速度。  通信简便：线程之间可以通过共享内存进行通信，但需要注意同步问题。</code></pre><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><pre><code class="hljs">  资源共享：线程共享相同的地址空间，可以更容易地进行数据共享。  效率：相比于进程，线程的创建和切换开销较小。</code></pre><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>PS: 面试官有口音,我一直听的是”写程”</p><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><pre><code class="hljs">  协程是一种轻量级的线程，它由程序员自己控制，不依赖于操作系统的线程和进程。协程通常运行在单个线程内，  通过协作式多任务实现并发。  协程是一种用户态的轻量级线程，由程序员主动控制，可以在不同的执行流之间切换。协程通常不被操作系统内核  所管理，而是由用户空间的库来支持。</code></pre><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><pre><code class="hljs">  用户态调度：协程的调度不依赖于操作系统内核，而是由用户程序自己实现。  非抢占式：协程的执行不会被强制中断，需要主动让出执行权。  (协作式：协程是协作式多任务处理，不同于线程的抢占式多任务处理。)  轻量级：协程相对于线程更轻量，切换开销较小。  共享状态：协程通常共享相同的地址空间，可以更方便地共享状态。</code></pre><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><pre><code class="hljs">  高并发：协程可以在单线程内实现高并发，适用于 I/O 密集型任务。  简化编程：相比于多线程编程，协程更容易理解和维护。</code></pre><h3 id="关系和区别"><a href="#关系和区别" class="headerlink" title="关系和区别"></a>关系和区别</h3><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><pre><code class="hljs">  a. 进程和线程是操作系统层面的概念，而协程是一种编程语言层面的概念。  b. 进程可以包含多个线程，而线程可以包含多个协程。</code></pre><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><pre><code class="hljs">  1. 隔离性      a. 进程具有较高的隔离性，各个进程之间不能直接访问彼此的内存空间。线程共享同一进程的资源，因此具有  较低的隔离性。      b. 协程通常在同一地址空间中运行，共享状态，隔离性相对较低。  2. 创建和销毁开销      a. 进程的创建和销毁开销较大，线程的开销较小。      b .协程的创建和销毁开销更小。  3. 并发性      a. 进程和线程是操作系统提供的并发执行的基本单位，由操作系统进行调度。      b. 协程通常由程序员主动控制调度，实现协作式的并发。  4. 切换开销      a. 进程和线程的切换由操作系统负责，开销较大。      b. 协程的切换由用户程序自己控制，开销相对较小。  5. 共享资源      a. 进程和线程共享相同进程的资源，但进程之间的资源相互隔离。      b. 协程通常在同一地址空间中运行，共享状态。  6. 使用场景      进程通常适用于多核心处理器，线程适用于多任务处理，而协程适用于IO密集型任务。</code></pre><h2 id="5-线程同步有哪些"><a href="#5-线程同步有哪些" class="headerlink" title="5. 线程同步有哪些"></a>5. 线程同步有哪些</h2><p>线程同步是在多线程环境中为了协调不同线程的执行顺序，确保共享资源的正确访问而采取的一系列手段。以下是一些常见的线程同步机制：</p><h4 id="1-互斥锁-Mutex"><a href="#1-互斥锁-Mutex" class="headerlink" title="(1) 互斥锁(Mutex) :"></a>(1) 互斥锁(Mutex) :</h4><pre><code class="hljs">  互斥锁是一种最常见的线程同步机制。它确保在任何时刻只有一个线程可以访问共享资源，其他线程需要等待  锁的释放。</code></pre><h4 id="2-信号量-Semaphore"><a href="#2-信号量-Semaphore" class="headerlink" title="(2) 信号量(Semaphore) :"></a>(2) 信号量(Semaphore) :</h4><pre><code class="hljs">  信号量是一个计数器，用于控制同时访问共享资源的线程数量。它允许多个线程同时访问，但在超过一定数量  时需要等待。</code></pre><h4 id="3-条件变量-Condition-Variable"><a href="#3-条件变量-Condition-Variable" class="headerlink" title="(3) 条件变量(Condition Variable) :"></a>(3) 条件变量(Condition Variable) :</h4><pre><code class="hljs">  条件变量用于在线程之间发送信号，通知其他线程某个条件的变化。通常与互斥锁一起使用，以确保线程在条  件满足时被唤醒。</code></pre><h4 id="4-读写锁-Read-Write-Lock"><a href="#4-读写锁-Read-Write-Lock" class="headerlink" title="(4) 读写锁(Read-Write Lock) :"></a>(4) 读写锁(Read-Write Lock) :</h4><pre><code class="hljs">  读写锁允许多个线程同时读取共享资源，但只允许一个线程写入。这有助于提高读取性能。</code></pre><h4 id="5-屏障-Barrier"><a href="#5-屏障-Barrier" class="headerlink" title="(5) 屏障(Barrier) :"></a>(5) 屏障(Barrier) :</h4><pre><code class="hljs">  屏障用于在多个线程中设置一个等待点，当所有线程都到达这个点时，它们才能继续执行。</code></pre><h4 id="6-自旋锁（Spin-Lock）"><a href="#6-自旋锁（Spin-Lock）" class="headerlink" title="(6) 自旋锁（Spin Lock）:"></a>(6) 自旋锁（Spin Lock）:</h4><pre><code class="hljs">  自旋锁是一种互斥机制，但不同于互斥锁需要阻塞线程，自旋锁会让线程在获取不到锁时一直自旋等待。</code></pre><h4 id="7-原子操作（Atomic-Operation）"><a href="#7-原子操作（Atomic-Operation）" class="headerlink" title="(7) 原子操作（Atomic Operation）:"></a>(7) 原子操作（Atomic Operation）:</h4><pre><code class="hljs">  原子操作是在不被中断的情况下执行的操作，确保它们是不可分割的。原子操作通常用于实现一些简单的同步操作，  如递增、递减等。</code></pre>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>C/C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++项目&lt;&lt;日志系统&gt;&gt;</title>
    <link href="/2023/07/31/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/07/31/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>前言：C++项目<br>作用: 将一条消息,进行格式化称为指定格式的字符串后,写入到指定位置</p><ol><li><p>日志要写入到指定位置(标准输出,指定文件,滚动文件,…(可扩展))</p><p>日志系统需要支持将日志消息落地到不同的位置 —多落地方向</p></li><li><p>日志写入指定位置,支持不同的写入方式(同步,异步)</p><p>同步:业务线程自己负责日志的写入(流程简单,但是有可能会因为阻塞导致效率降低)</p><p>异步:业务线程将日志放入缓冲区内存,让其他异步线程负责将日志写入到指定位置</p></li><li><p>日志输出以日志器为单位,支持多日志器(不同的项目组有不同的输出策略)</p><p>包括日志器的管理</p></li></ol>          </div><div class="note note-danger">            <p>模块划分:</p><ol><li>日志等级模块 —对输出日志的等级进行划分</li></ol>          </div>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言结构体对齐与位段</title>
    <link href="/2023/07/26/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/07/26/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="结构体对齐规则"><a href="#结构体对齐规则" class="headerlink" title="结构体对齐规则"></a>结构体对齐规则</h2><ol><li><p>第一个成员在与结构体变量偏移量为0的地址处</p></li><li><p>其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处</p><p> <code>对齐数=编译器默认的一个对齐数与该成员大小的较小值</code></p></li><li><p>结构体总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍</p></li><li><p>如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍</p></li></ol><p>设置默认对齐数<br><code>#pragma pack(int)</code></p><p>恢复默认对齐数<br><code>#pragma pack()</code></p><span id="more"></span><h2 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S1</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c1;  <span class="hljs-comment">//1</span><br>    <span class="hljs-type">int</span> i;    <span class="hljs-comment">//4</span><br>    <span class="hljs-type">char</span> c2;  <span class="hljs-comment">//1</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S2</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c1;    <span class="hljs-comment">//1</span><br>    <span class="hljs-type">char</span> c2;    <span class="hljs-comment">//1</span><br>    <span class="hljs-type">int</span> i;      <span class="hljs-comment">//4</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S3</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">double</span> d;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> i;<br>&#125;;<br><span class="hljs-comment">/*d首先从0开始，占8个字节，0~7，然后c是char类型，大小一个字节，小于默认对齐数，所以c放在8位置，接下来i是int类型，占4个字节，小于默认对齐数，所以取4的倍数作为i的存放地址，及从12开始放，12~15，总大小0~15共16个字节，是8的倍数*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S4</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c1;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S3</span> <span class="hljs-title">s3</span>;</span><br>    <span class="hljs-type">double</span> d;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S1</span> <span class="hljs-title">s1</span>;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,offsetof(<span class="hljs-keyword">struct</span> S1, c1));<span class="hljs-comment">//0</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,offsetof(<span class="hljs-keyword">struct</span> S1, i)); <span class="hljs-comment">//4</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,offsetof(<span class="hljs-keyword">struct</span> S1, c2));<span class="hljs-comment">//8</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> S1));    <span class="hljs-comment">//12</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,offsetof(<span class="hljs-keyword">struct</span> S2, c1)); <span class="hljs-comment">//0</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,offsetof(<span class="hljs-keyword">struct</span> S2, c2)); <span class="hljs-comment">//1</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,offsetof(<span class="hljs-keyword">struct</span> S2, i));  <span class="hljs-comment">//4</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> S2));     <span class="hljs-comment">//8</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,offsetof(<span class="hljs-keyword">struct</span> S3, d)); <span class="hljs-comment">//0</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,offsetof(<span class="hljs-keyword">struct</span> S3, c)); <span class="hljs-comment">//8</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,offsetof(<span class="hljs-keyword">struct</span> S3, i)); <span class="hljs-comment">//12</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> S3));    <span class="hljs-comment">//16</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,offsetof(<span class="hljs-keyword">struct</span> S4, c1)); <span class="hljs-comment">//0</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,offsetof(<span class="hljs-keyword">struct</span> S4, s3)); <span class="hljs-comment">//8</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,offsetof(<span class="hljs-keyword">struct</span> S4, d));  <span class="hljs-comment">//24</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> S4));     <span class="hljs-comment">//32</span><br><br>    <span class="hljs-comment">//printf(&quot;%d\n&quot;,sizeof(struct S1)); //12</span><br>    <span class="hljs-comment">//printf(&quot;%d\n&quot;,sizeof(struct S2)); // 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构体传参"><a href="#结构体传参" class="headerlink" title="结构体传参"></a>结构体传参</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> data[<span class="hljs-number">1000</span>];<br>    <span class="hljs-type">int</span> num;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print1</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> S s)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d\n&quot;</span>,s.data[<span class="hljs-number">0</span>],s.data[<span class="hljs-number">1</span>],s.data[<span class="hljs-number">2</span>],s.num);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print2</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> S *p)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d\n&quot;</span>,p-&gt;data[<span class="hljs-number">0</span>],p-&gt;data[<span class="hljs-number">1</span>],p-&gt;data[<span class="hljs-number">2</span>],p-&gt;num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,(*p).data[<span class="hljs-number">0</span>],(*p).num);<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> <span class="hljs-title">ss</span> =</span> &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,<span class="hljs-number">5</span>&#125;;<br>    print1(ss);<br>    print2(&amp;ss);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h2><ol><li>位段的成员必须是int､unsigned int或signed int</li><li>位段的成员名后边有一个冒号和一个数字</li></ol><h3 id="位段的内存分配"><a href="#位段的内存分配" class="headerlink" title="位段的内存分配"></a>位段的内存分配</h3><ol><li>位段的成员可以是int､unsigned int､signed int或者是char类型</li><li>位段的空间上是按照需要以4个字节(int)或者1个字节(char)的方式来开辟的</li><li>位段涉及很多不确定因素，位段是不跨平台的，注重可移植性的程序应该避免使用位段</li></ol><h3 id="位段的跨平台问题"><a href="#位段的跨平台问题" class="headerlink" title="位段的跨平台问题"></a>位段的跨平台问题</h3><ol><li>int位段被当成有符号数还是无符号数是不确定的 </li><li>位段中最大位的数目不能确定，(16位机器最大16，32位机器最大32，写成27，在16位机器会出问题)</li><li>位段中的成员在内存重从左向右分配还是从右向左分配尚未定义</li><li>当一个结构包含两个位段，第二个位段成员比较大，无法容纳第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//位段</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-type">int</span> d;<br>&#125;;<br><span class="hljs-comment">//A就是一个位段类型</span><br><span class="hljs-comment">//位段-其中的位其实是二进制位(bit位)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">//int型先分配4byte = 32bit</span><br>    <span class="hljs-type">int</span> _a:<span class="hljs-number">2</span>;   <span class="hljs-comment">//use 2bit,  32 - 2 = 30bit</span><br>    <span class="hljs-type">int</span> _b:<span class="hljs-number">5</span>;   <span class="hljs-comment">//use 5bit,  30 - 5 = 25bit</span><br>    <span class="hljs-type">int</span> _c:<span class="hljs-number">10</span>;  <span class="hljs-comment">//use 10bit, 25 - 10 = 15bit</span><br>    <span class="hljs-type">int</span> _d:<span class="hljs-number">30</span>;  <span class="hljs-comment">//15 &lt; 30,not enough,int型,再分4byte,15 + 32 - 30 = 17bit</span><br>    <span class="hljs-comment">//总共分配了8bit</span><br>&#125;;<br><span class="hljs-comment">//47bit</span><br><span class="hljs-comment">//1byte = 8bit</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S1</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> a:<span class="hljs-number">3</span>;<br>    <span class="hljs-type">char</span> b:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">char</span> c:<span class="hljs-number">5</span>;<br>    <span class="hljs-type">char</span> d:<span class="hljs-number">4</span>;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// printf(&quot;%d\n&quot;,sizeof(struct S));//16</span><br>    <span class="hljs-comment">// printf(&quot;%d\n&quot;,sizeof(struct A));//8</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S1</span> <span class="hljs-title">s</span> =</span> &#123;<span class="hljs-number">0</span>&#125;;<br>    s.a = <span class="hljs-number">10</span>;<br>    s.b = <span class="hljs-number">12</span>;<br>    s.c = <span class="hljs-number">3</span>;<br>    s.d = <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d\n&quot;</span>,s.a,s.b,s.c,s.d);<span class="hljs-comment">//2 -4 3 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>位段在合适的情况下可以节省空间</p><p>位段不存在内存对齐 </p>          </div></li></ol>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言动态内存基础知识</title>
    <link href="/2023/07/26/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <url>/2023/07/26/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>C语言精华之一</p>          </div><h1 id="动态内存函数的介绍"><a href="#动态内存函数的介绍" class="headerlink" title="动态内存函数的介绍"></a>动态内存函数的介绍</h1><p>动态内存分配实在堆区完成</p><h2 id="malloc-和-free"><a href="#malloc-和-free" class="headerlink" title="malloc 和 free"></a>malloc 和 free</h2><h3 id="malloc函数和free"><a href="#malloc函数和free" class="headerlink" title="malloc函数和free"></a>malloc函数和free</h3><p>void *malloc(size_t size);<br>这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针<br>如果开辟成功则返回一个指向开辟好空间的指针<br>如果开辟失败，则返回一个NULL指针，因此其返回值一定要做检查</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">40</span>);<br>    <span class="hljs-type">int</span> *q = p;<br>    <span class="hljs-comment">//   int *p = (int *)malloc(-3);</span><br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,<span class="hljs-built_in">strerror</span>(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//使用</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        *p = i;<br>        p++;<br>    &#125;<br>    <span class="hljs-comment">//输出，在上一个循环中，p不断后移，指向最后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i ++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,(*q));<br>        q++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-comment">//释放</span><br>    <span class="hljs-built_in">free</span>(q);<br>    p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h2><p>void *calloc(size_t num,size_t size);<br>函数的功能是为num个大小为size的元素开辟一块空间，并且把空间的每个字节初始化为0<br>与malloc的区别只在与calloc会在返回地址之前把申请的空间的每个字节初始化为全0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//40个字节</span><br>    <span class="hljs-comment">//malloc(40)</span><br>    <span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">10</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        *(p + i) = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*p);<br>        p ++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(p);<br>    p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h2><p>realloc函数的出现让动态内存管理更加灵活<br>realloc函数可以做到对动态开辟内存大小的调整<br>void *realloc(void *ptr,size_t size);<br>ptr是要调整的内存地址<br>size调整之后新大小<br>返回值为调整之后的内存起始位置<br>这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的内存空间<br>realloc在调整内存空间的是存在两种情况：</p><ol><li><p>原有空间之后有足够大空间</p></li><li><p>若传的是空指针，realloc(NULL,40)就等价于malloc(40)</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">40</span>);<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        *(p + i) = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*(p + i));<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-comment">//增加空间</span><br>    <span class="hljs-type">int</span> *q = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">realloc</span>(p, <span class="hljs-number">80</span>);<br>    <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        p = q;<br>        q = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">10</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>    &#123;<br>        *(p + i) = i;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*(p + i));<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-built_in">free</span>(p);<br>    p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st_type</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">0</span>];<span class="hljs-comment">//柔性数组成员</span><br>&#125;type_a;<br></code></pre></td></tr></table></figure><h3 id="柔性数组一"><a href="#柔性数组一" class="headerlink" title="柔性数组一"></a>柔性数组一</h3><p>结构体中的最后一个元素允许是未知大小的数组，这就叫做<code>柔性数组</code>成员</p><p>特点</p><ol><li>结构中的柔性数组成员前面必须至少有一个其他成员</li><li>sizeof返回的这种结构大小不包括柔性数组的内存</li><li>包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">float</span> s;<br>    <span class="hljs-type">int</span> arr[];<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> *<span class="hljs-title">ps</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> *<span class="hljs-title">p</span> =</span> (<span class="hljs-keyword">struct</span> S *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> S) + <span class="hljs-number">4</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        ps = p;<br>    ps-&gt;n = <span class="hljs-number">100</span>;<br>    ps-&gt;s = <span class="hljs-number">5.5f</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;ps-&gt;arr[i]);<br>    &#125; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ps-&gt;arr[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-comment">//扩展</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> *<span class="hljs-title">pps</span> =</span> <span class="hljs-built_in">realloc</span>(ps,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> S) + <span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (pps == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        ps = pps;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;ps-&gt;arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ps-&gt;arr[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="柔性数组二"><a href="#柔性数组二" class="headerlink" title="柔性数组二"></a>柔性数组二</h3><p>另外一个例子(非柔性数组，结构体里放指针)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">float</span> s;<br>    <span class="hljs-type">int</span> *arr;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> *<span class="hljs-title">ps</span> =</span> (<span class="hljs-keyword">struct</span> S *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> S));<br>    ps-&gt;n = <span class="hljs-number">100</span>;<br>    ps-&gt;s = <span class="hljs-number">5.5f</span>;<br>    <span class="hljs-type">int</span> *ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        ps-&gt;arr = ptr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,(ps-&gt;arr + i));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ps-&gt;arr[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-comment">//扩展</span><br>    <span class="hljs-type">int</span> *str = <span class="hljs-built_in">realloc</span>(ps-&gt;arr, <span class="hljs-number">8</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span>(str == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        ps-&gt;arr = str;    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,(ps-&gt;arr + i));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*(ps-&gt;arr + i));<br>    &#125;<br><br><br><br>    <span class="hljs-comment">//释放</span><br>    <span class="hljs-built_in">free</span>(ps-&gt;arr);<br>    ps-&gt;arr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">free</span>(ps);<br>    ps = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言指针进阶知识</title>
    <link href="/2023/07/24/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/07/24/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="指针的进阶"><a href="#指针的进阶" class="headerlink" title="指针的进阶"></a>指针的进阶</h1><ol><li>指针就是个变量，用来存放地址，地址唯一标识一块内存空间</li><li>指针的大小是固定的4&#x2F;8个字节（32位平台&#x2F;64位平台）</li><li>指针是有类型，指针的类型决定了指针的+&#x2F;-整数的步长，指针解引用操作的时候的权限</li><li>指针的运算</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<span class="hljs-comment">//整型数组</span><br><br><span class="hljs-type">int</span> *parr1[<span class="hljs-number">10</span>];<span class="hljs-comment">//指针数组</span><br><br><span class="hljs-type">int</span> (*parr2)[<span class="hljs-number">10</span>];<span class="hljs-comment">//数组指针</span><br><br><span class="hljs-type">int</span> ((*parr3)[<span class="hljs-number">10</span>])[<span class="hljs-number">5</span>]<span class="hljs-comment">//指针数组（存放数组指针的数组）</span><br><span class="hljs-comment">//parr3有十个元素，每个元素指向一个有五个元素的数组</span><br></code></pre></td></tr></table></figure><h2 id="数组传参和指针传参"><a href="#数组传参和指针传参" class="headerlink" title="数组传参和指针传参"></a>数组传参和指针传参</h2><ol><li><p>一维数组传参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>         <span class="hljs-comment">//ok</span><br>&#123;&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>])</span>       <span class="hljs-comment">//ok</span><br>&#123;&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr)</span>          <span class="hljs-comment">//ok</span><br>&#123;&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr[<span class="hljs-number">20</span>])</span>     <span class="hljs-comment">//ok</span><br>&#123;&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-type">int</span> **arr)</span>        <span class="hljs-comment">//ok</span><br>&#123;&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> *arr2[<span class="hljs-number">20</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//一维整型指针数组</span><br>    test(arr);<br>    test2(arr2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二维数组传参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">5</span>])</span>         <span class="hljs-comment">//ok</span><br>&#123;&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[][])</span>           <span class="hljs-comment">//不行</span><br>&#123;&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[][<span class="hljs-number">5</span>])</span>          <span class="hljs-comment">//ok</span><br>&#123;&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr)</span>              <span class="hljs-comment">//不行</span><br>&#123;&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr[<span class="hljs-number">5</span>])</span>           <span class="hljs-comment">//不行</span><br>&#123;&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> (*arr)[<span class="hljs-number">5</span>])</span>         <span class="hljs-comment">//ok</span><br>&#123;&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> **arr)</span>             <span class="hljs-comment">//不行</span><br>&#123;&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    test(arr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一级指针传参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> *p, <span class="hljs-type">int</span> sz)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*(p + i));<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-type">int</span> *p = arr;<br>    <span class="hljs-type">int</span> sz = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>    print(p,sz);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二级指针传参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> **ptr)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num = %d\n&quot;</span>,**ptr);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> *p = &amp;n;<br>    <span class="hljs-type">int</span> **pp = &amp;p;<br>    test(pp);<br>    test(&amp;p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// //Add 和 &amp;Add 都是函数的地址，没有区别</span><br>    <span class="hljs-comment">// printf(&quot;%p\n&quot;,Add);</span><br>    <span class="hljs-comment">// printf(&quot;%p\n&quot;,&amp;Add);</span><br>    <span class="hljs-type">int</span> (*pf)(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y) = &amp;Add;<br>    <span class="hljs-comment">//int (*pf)(int x,int y) = Add;</span><br>    <span class="hljs-comment">//pf是函数指针变量</span><br>    <span class="hljs-type">int</span> sum = (*pf)(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">//int sum = pf(3,5);</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有趣的代码<code>( *( void(*)() )0 )()</code>:</p><ol><li><p>( void(*)() )0 –&gt;把0当作一个函数的地址，强制类型转换</p></li><li><p>把0直接转换成一个void(*)()的函数指针，然后去调用0地址处的函数</p></li></ol><p>有趣的代码<code>void (* signal(int ,void(*)(int)) )(int);</code></p><ol><li>上述代码是一次函数声明</li><li>声明的函数叫：signal</li><li>signal函数的第一个参数是int类型</li><li>signal函数的第二个参数是一个函数指针类型，该函数指针指向的函数参数是int，返回值是void</li><li>signal函数的返回类型也是一个函数指针类型，该函数指向的函数参数是int，返回类型是void</li><li><code>typedef void(* pf_t)(int);</code>&#x2F;&#x2F;把void(*)(int)函数指针类型换名为pf_t</li><li><code>pf_t signal(int,pf_t);</code></li></ol><h2 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h2><p>函数指针</p><p><code>int(*pf)(int,int)</code></p><p>函数指针数组</p><p><code>int (*pfArr[4])(int,int)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Sub</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> x - y;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//int (*pt)(const char *str,double d) = &amp;test;</span><br>    <span class="hljs-type">int</span> (*pfArr[<span class="hljs-number">2</span>])(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>) = &#123;Add,Sub&#125;;<br>    <span class="hljs-type">int</span> sum = pfArr[<span class="hljs-number">0</span>](<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-type">int</span> anw = pfArr[<span class="hljs-number">1</span>](<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,sum,anw);<span class="hljs-comment">//3 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用函数指针数组实现简易计算器</p><p>函数指针数组的实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//写一个计算器</span><br><span class="hljs-comment">//加减乘除</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Menu</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;******************************\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*********1.add  2.sub*********\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*********3.mul  4.div*********\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*********0.exit      *********\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;******************************\n&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Sub</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> x - y;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Mul</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> x * y;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Div</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> x / y;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> input = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> anw = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> (*pfArr[<span class="hljs-number">5</span>])(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>) = &#123;<span class="hljs-number">0</span>, Add, Sub, Mul, Div&#125;;<br>    <span class="hljs-keyword">do</span> &#123;<br>    Menu();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请选择:&gt;&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;input);<br>    <span class="hljs-keyword">if</span>(input == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span>(input &gt;= <span class="hljs-number">1</span> &amp;&amp; input &lt;= <span class="hljs-number">4</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入两个操作数:&gt;&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>        anw = pfArr[input](x,y);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,anw);<br>    &#125;<br>    <span class="hljs-comment">// switch (input) &#123;</span><br>    <span class="hljs-comment">// case 1:printf(&quot;%d\n&quot;,Add(x, y));break;</span><br>    <span class="hljs-comment">// case 2:printf(&quot;%d\n&quot;,Sub(x, y));break;</span><br>    <span class="hljs-comment">// case 3:printf(&quot;%d\n&quot;,Mul(x, y));break;</span><br>    <span class="hljs-comment">// case 4:printf(&quot;%d\n&quot;,Div(x, y));break;</span><br>    <span class="hljs-comment">// case 0:printf(&quot;QUIT\n&quot;);break;</span><br>    <span class="hljs-comment">// default:printf(&quot;ERROR\n&quot;);break;</span><br>    <span class="hljs-comment">// &#125;</span><br>    &#125;<span class="hljs-keyword">while</span> (input);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="指向函数指针数组的指针"><a href="#指向函数指针数组的指针" class="headerlink" title="指向函数指针数组的指针"></a>指向函数指针数组的指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><br>&#123;&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Sub</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><br>&#123;&#125;<br>函数指针<br><span class="hljs-type">int</span> (*pf)(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)<br>函数指针数组<br><span class="hljs-type">int</span> (*pfArr[<span class="hljs-number">2</span>])(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)<br>指向函数指针数组的指针<br><span class="hljs-type">int</span> (* (*ptr)[<span class="hljs-number">2</span>])(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>) = &amp;pfArr<br></code></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数就是一个通过函数指针调用的函数。如果把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> *c[] = &#123;<span class="hljs-string">&quot;ENTER&quot;</span>,<span class="hljs-string">&quot;NEW&quot;</span>,<span class="hljs-string">&quot;POINT&quot;</span>,<span class="hljs-string">&quot;FIRST&quot;</span>&#125;;<br>    <span class="hljs-type">char</span> **cp[] = &#123;c + <span class="hljs-number">3</span>, c + <span class="hljs-number">2</span>, c + <span class="hljs-number">1</span>, c&#125;;<br>    <span class="hljs-type">char</span> ***cpp = cp;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,**++cpp);         <span class="hljs-comment">//POINT</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,*--*++cpp+<span class="hljs-number">3</span>);     <span class="hljs-comment">//ER</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,*cpp[<span class="hljs-number">-2</span>]+<span class="hljs-number">3</span>);      <span class="hljs-comment">//ST</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,cpp[<span class="hljs-number">-1</span>][<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);   <span class="hljs-comment">//EW</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
